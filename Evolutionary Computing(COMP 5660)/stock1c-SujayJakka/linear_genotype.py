

# linear_genotype.py

import random
from copy import deepcopy
from snake_eyes import read_config

class LinearGenotype():
    def __init__(self):
        self.fitness = None
        self.genes = None


    def random_initialization(self, shapes, bounds, **kwargs):
        # TODO: Initialize self.genes, using the input parameters.
        #       It should be an indexable data structure of length len(shapes),
        #       where each element is an indexable data structure of length 3.
        #       The first value of each element should be an integer within the
        #       half-open interval [bounds[0][0], bounds[0][1]). The second should be
        #       similar, within [bounds[1][0], bounds[1][1]). The third should be
        #       either 0, 1, 2, or 3. All values should be chosen uniform randomly.

        # An array is used as the underlying data structure for the Linear Genotype
        self.genes = []

        # We are generating a random x, y, and r value for each shape and adding it to our Linear Genotype
        for i in range(len(shapes)):

            # We subtract by 1 as the random.randint method is inclusive for both endpoints
            x_value = random.randint(bounds[0][0], bounds[0][1] - 1)
            y_value = random.randint(bounds[1][0], bounds[1][1] - 1)
            
            r_value = random.randint(0, 3)
            self.genes.append((x_value, y_value, r_value))


    def serialize(self):
        # TODO: Return a string representation of self.genes

        # Converts self.genes from an array of tuples into a string and returns it
        return str(self.genes)


    def deserialize(self, serialization):
        # TODO: Recreate self.genes from serialization,
        #       which is a string generated by your serialize method

        # Converts the string serialization to an array of tuples and assigns it to the self.genes instance variable
        self.genes = eval(serialization)
        

    def recombine(self, mate, method, **kwargs):
        child = LinearGenotype()

        # TODO: Recombine genes of self with mate and
        #       assign to child's genes member variable
        assert method.casefold() in {'uniform', 'one-point', 'bonus'}
        if method.casefold() == 'uniform':
            # Perform uniform recombination

            # The probability of the child inheriting a gene from parent 1(self) is kwargs[prob_selecting_parent_1_gene]
            child.genes = []
            for i in range(len(self.genes)):
                random_prob = random.uniform(0, 1)
                if random_prob <= kwargs["prob_selecting_parent_1_gene"]:
                    child.genes.append(self.genes[i])
                else:
                    child.genes.append(mate.genes[i])

        elif method.casefold() == 'one-point':
            # Perform one-point crossover

            # Choose a crossover point, e.g. crossover point 0 is between loci 0 and loci 1
            crossover_point = random.randint(0, len(self.genes) - 2)
            # Combine genes from both parents, everything left of the crossover point is from parent 1(self) everything right 
            # of the crossover point is from parent 2(mate)
            child.genes = self.genes[:crossover_point + 1] + mate.genes[crossover_point + 1:]
            

        elif method.casefold() == 'bonus':
            # This is a red deliverable (i.e., bonus for anyone).
            # Implement the bonus crossover operator as described
            # in deliverable Red 1 of Assignment 1b.
            pass

        return child


    def mutate(self, bounds, bonus=None, **kwargs):
        mutant = LinearGenotype()
        mutant.genes = deepcopy(self.genes)

        # Create Bound Variables
        x_min = bounds[0][0]
        x_max = bounds[0][1] - 1
        y_min = bounds[1][0]
        y_max = bounds[1][1] - 1

        if not bonus:
            # TODO: Mutate genes of mutant
            for i in range(len(mutant.genes)):

                # Create mutation variables for the x, y, and r values
                mutated_x = None
                mutated_y = None
                mutated_rotation = None

                # Find the random prob to creep mutation
                random_prob = random.uniform(0, 1)

                prob_creep_mutation = kwargs["prob_creep_mutation"]

                # If this random prob <= the set prob of creep mutation we will apply a creep mutation
                # Else we will use the x and y value
                if random_prob <= prob_creep_mutation:

                    # Find x and y of gene using creep mutation
    
                    # Find the mean and std of our guassian distribution for the amount of change we will add to our x, y, and r
                    mean_of_change_dist = kwargs["mean_of_change_dist"]
                    std_of_change_dist = kwargs["std_of_change_dist"]
    
                    # Find the change for the x coordinate
                    change_for_x = random.gauss(mean_of_change_dist, std_of_change_dist)
                    # Sum our current x coordinate and our change for x and set it to a temp variable
                    # Round to make sure it is an integer
                    temp_mutation_x = round(mutant.genes[i][0] + change_for_x)
                    # Make sure this temp value is in bounds
                    while temp_mutation_x > x_max or temp_mutation_x < x_min:
                        change_for_x = random.gauss(mean_of_change_dist, std_of_change_dist)
                        temp_mutation_x = round(mutant.genes[i][0] + change_for_x)
                    # Set the temp value to our mutated_x variable
                    mutated_x = temp_mutation_x
    
                    # Find the change for the y coordinate
                    change_for_y = random.gauss(mean_of_change_dist, std_of_change_dist)
                    # Sum our current y coordinate and our change for y and set it to a temp variable
                    # Round to make sure it is an integer
                    temp_mutation_y = round(mutant.genes[i][1] + change_for_y)
                    # Make sure this temp value is in bounds
                    while temp_mutation_y > y_max or temp_mutation_y < y_min:
                        change_for_y = random.gauss(mean_of_change_dist, std_of_change_dist)
                        temp_mutation_y = round(mutant.genes[i][1] + change_for_y)
                    # Set the temp value to our mutated_y variable
                    mutated_y = temp_mutation_y
                    
                else:
                    mutated_x, mutated_y = mutant.genes[i][0], mutant.genes[i][1]
                
                # Find mutated rotation using random reset

                # Find the random prob to random reset
                random_prob = random.uniform(0, 1)
                
                prob_random_reset = kwargs["prob_random_reset"]

                # If this random prob <= the set prob of random reset we will apply a random reset
                # Else we will use the old rotation value
                if random_prob <= prob_random_reset:
                    mutated_rotation = random.randint(0, 3)
                else:
                    mutated_rotation = mutant.genes[i][2]
                    
                mutant.genes[i] = (mutated_x, mutated_y, mutated_rotation)
        
        else:
            # This is a red deliverable (i.e., bonus for anyone).
            # Implement the bonus mutation operator as described
            # in deliverable Red 1 of Assignment 1b.
            pass

        return mutant


    @classmethod
    def initialization(cls, mu, *args, **kwargs):
        population = [cls() for _ in range(mu)]
        for i in range(len(population)):
            population[i].random_initialization(*args, **kwargs)
        return population