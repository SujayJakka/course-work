
# tree_genotype.py

import random
from copy import deepcopy
from fitness import manhattan

# Node Class that is used to make up the objects for TreeGenotype()
class Node():
    def __init__(self, primitive):
        self.primitive = primitive
        self.left = None
        self.right = None
        
def full_method(curr_depth, **kwargs):

    # Will create a terminal node if it reaches depth limit
    # Will create either a G, P, F, W, or Constant Node
    if curr_depth == kwargs["depth_limit"]:
        terminal_type = random.randint(0, 4)
        if terminal_type != 4:
            terminal_node = Node(kwargs["terminals"][terminal_type])
            return terminal_node
        else:
            constant_range = kwargs["constant_range"]
            terminal_node = Node(random.uniform(constant_range[0], constant_range[1]))
            return terminal_node
    # If not at depth limit will create another nonterminal node
    # The possible nonterminal nodes that it can create are +, -, *, /, or RAND
    else:
        nonterminal_type = random.randint(0, 4)
        nonterminal_node = Node(kwargs["nonterminals"][nonterminal_type])
        nonterminal_node.left = full_method(curr_depth + 1, **kwargs)
        nonterminal_node.right = full_method(curr_depth + 1, **kwargs)
        return nonterminal_node

# Same as the full method except we are able to create a terminal node even when we are not at the depth limit
# There is a 50/50 chance of creating a terminal or nonterminal node at any depth except for the depth limit,
# where we are forced to choose a terminal node
def grow_method(curr_depth, **kwargs):
    continue_depth = random.randint(0, 1)

    # Will create a terminal node if it reaches depth limit or if we randomly select 0
    # Will create either a G, P, F, W, or Constant Node
    if curr_depth == kwargs["depth_limit"] or continue_depth == 0:
        terminal_type = random.randint(0, 4)
        if terminal_type != 4:
            terminal_node = Node(kwargs["terminals"][terminal_type])
            return terminal_node
        else:
            constant_range = kwargs["constant_range"]
            terminal_node = Node(random.uniform(constant_range[0], constant_range[1]))
            return terminal_node
    # If not at depth limit will create another nonterminal node
    # The possible nonterminal nodes that it can create are +, -, *, /, or RAND
    else:
        nonterminal_type = random.randint(0, 4)
        nonterminal_node = Node(kwargs["nonterminals"][nonterminal_type])
        nonterminal_node.left = grow_method(curr_depth + 1, **kwargs)
        nonterminal_node.right = grow_method(curr_depth + 1, **kwargs)
        return nonterminal_node
    

class TreeGenotype():
    def __init__(self):
        self.fitness = None
        self.genes = None


    @classmethod
    def initialization(cls, mu, depth_limit, **kwargs):
        population = [cls() for _ in range(mu)]

        # 2a TODO: Initialize genes member variables of individuals
        #          in population using ramped half-and-half.
        #          Pass **kwargs to your functions to give them
        #          the sets of terminal and nonterminal primitives.

        # For every individual in the population it has a random chance of being initialized with the grow or full method
        # The probability for selecting the full method is set in the config
        # There is also a uniform chance of selecting a depth_limit in the range [1, depth_limit]
        for individual in population:
            prob_of_full_method = random.uniform(0, 1)
            rand_depth_limit = random.randint(1, depth_limit)
            
            if prob_of_full_method <= kwargs["prob_of_full_method"]:
                individual.genes = full_method(0, depth_limit=rand_depth_limit, **kwargs)
            else:
                individual.genes = grow_method(0, depth_limit=rand_depth_limit, **kwargs)

        return population


    def serialize(self):
        # 2a TODO: Return a string representing self.genes in the required format.

        # Array to join all the serialized strings at the very end
        # O(n^2) -> O(n)
        serialized_string = []

        def preorder_traversal(node, curr_depth):
            if node is None:
                return
                
            serialized_string.append(("|" * curr_depth) + str(node.primitive)+ "\n")
            preorder_traversal(node.left, curr_depth + 1)
            preorder_traversal(node.right, curr_depth + 1)

        preorder_traversal(self.genes, 0)
        return "".join(serialized_string)


    def deserialize(self, serialization):
        # 2a TODO: Complete the below code to recreate self.genes from serialization,
        #          which is a string generated by your serialize method.
        #          We have provided logic for tree traversal to help you get started,
        #          but you need to flesh out this function and make the genes yourself.

        def to_float_to_string(primitive):
            try:
                return float(primitive)
            except ValueError:
                return primitive

        lines = serialization.split('\n')

        # We pop the last element as each serialization has an unneccessary new line character at the end
        lines.pop()

        # TODO: Create the root node yourself here based on lines[0]
        root = Node(to_float_to_string(lines[0]))

        parent_stack = [(root, 0)]
        for line in lines[1:]:
            my_depth = line.count('|')
            my_primitive = line.strip('|')
            parent, parent_depth = parent_stack.pop()
            right_child = False
            while parent_stack and parent_depth >= my_depth:
                parent, parent_depth = parent_stack.pop()
                right_child = True

            # TODO: Create a node using the above variables as appropriate.
            node = Node(to_float_to_string(my_primitive))

            if not right_child:
                parent.left = node
            else:
                parent.right = node
            
            parent_stack.extend([(parent, parent_depth), \
                                 (node, my_depth)])

        # TODO: Use the data structure you've created to assign self.genes.
        self.genes = root


    def recombine(self, mate, depth_limit, **kwargs):
        child = self.__class__()

        # 2b TODO: Recombine genes of mate and genes of self to
        #          populate child's genes member variable.
        #          We recommend using deepcopy, but also recommend
        #          that you deepcopy the minimal amount possible.

        return child


    def mutate(self, depth_limit, **kwargs):
        mutant = self.__class__()
        mutant.genes = deepcopy(self.genes)

        # 2b TODO: Mutate mutant.genes to produce a modified tree.

        return mutant
